#pragma kernel SpreadRoots
#pragma kernel UpdateSoil

float4 RootData;

Texture2D<float4> BedrockHeightMap;
Texture2D<float4> SoilHeightMap;
RWTexture2D<float4> SoilMap;
RWTexture2D<float4> WaterMap;
RWTexture2D<float4> RootGrowth;
RWTexture2D<float4> Result;

static float MaxHeight = 200.0f; 
static float WidthInMeters = 400.0f;
static float WidthInPixels = 512.0f;
static float WaterAbsorbsionRate = 0.05f;

float GetBedrockHeight(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return BedrockHeightMap[pos].r * MaxHeight;
}
float GetSoilHeight(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return SoilHeightMap[pos].r * MaxHeight;
}
float GetSoilDepth(int2 xy)
{
	float diff = GetSoilHeight(xy) - GetBedrockHeight(xy);
	return clamp(diff, 0, MaxHeight);
}
float GetRootDepth(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return SoilMap[pos].g;
}
float GetWaterDepth(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return SoilMap[pos].b;
}

float GetSoakedWaterDepth(int2 xy)
{
	float currentWaterDepth = GetWaterDepth(xy);
	float newWaterDepth = currentWaterDepth * 0.4;
	int2 offsets[4] = { int2(1, 0), int2(-1, 0), int2(0, 1), int2(0, -1) };
	
	for (int i = 0; i < 4; i++) {
		int2 pos = xy + offsets[i];
		if (GetSoilDepth(pos) > currentWaterDepth * 0.1) {
			newWaterDepth += GetWaterDepth(pos) * 0.15;
		}
		else {
			newWaterDepth += GetWaterDepth(xy) * 0.15;
		}
	}

	return newWaterDepth;
}
float AbsorbWater(int2 xy, float amount)
{
	uint2 pos = clamp(xy, 0, 511);
	float availableWater = min(WaterMap[pos].b, WaterAbsorbsionRate);
	float absorbedWater = min(amount, availableWater);
	
	WaterMap[pos] = float4(WaterMap[pos].r, WaterMap[pos].g, WaterMap[pos].b - absorbedWater, WaterMap[pos].a - absorbedWater);
	
	return absorbedWater;
}
float ExpelWater(int2 xy, float amount)
{
	uint2 pos = clamp(xy, 0, 511);
	WaterMap[pos] = float4(WaterMap[pos].r, WaterMap[pos].g, WaterMap[pos].b + amount, WaterMap[pos].a + amount);
	return amount;
}

[numthreads(8,8,1)]
void SpreadRoots(uint3 id : SV_DispatchThreadID)
{
	float2 uv = RootData.xy;
	float2 xy = uv * WidthInPixels;
	float dist = distance(id.xy, xy);
	float radius = RootData.z;
	float depth = RootData.a; 
	float soilDepth = GetSoilDepth(id.xy);
	float growth = smoothstep(radius, 0, dist) * depth;
	growth = clamp(growth, 0, soilDepth);

	float oldRootDepth = GetRootDepth(id.xy);
	float rootDepth = oldRootDepth + growth;
	
	SoilMap[id.xy] = float4(soilDepth, rootDepth, 0, 0);
	RootGrowth[id.xy] += rootDepth - oldRootDepth;
}

[numthreads(8, 8, 1)]
void UpdateSoil(uint3 id : SV_DispatchThreadID)
{
	float soilDepth = GetSoilDepth(id.xy);
	float rootDepth = GetRootDepth(id.xy);
	float waterDepth = GetSoakedWaterDepth(id.xy);

	float excessWater = max(waterDepth - soilDepth, 0);
	waterDepth -= ExpelWater(id.xy, excessWater);
	float requestedWater = clamp(soilDepth - waterDepth, 0, WaterAbsorbsionRate);
	waterDepth += AbsorbWater(id.xy, requestedWater);

	Result[id.xy] = float4(soilDepth, rootDepth, waterDepth, 0);
}
