#pragma kernel UpdateSoil

RWTexture2D<float4> SoilMap;
RWTexture2D<float4> SoilWaterMap;
RWTexture2D<float4> WaterMap;
RWTexture2D<float4> Result;

static float MaxHeight = 200.0f; 
static float WidthInMeters = 400.0f;
static float WidthInPixels = 512.0f;
static float WaterAbsorpsionRate = 0.05f;

/*
*   Soil Map:
* R = Soil Depth
* G = Root Depth
* B = 
* A = Land Height
*
*   Soil Water Map:
* R = X Velocity
* G = Y Velocity
* B = Water Depth
* A = Water Height
*/

float GetSoilDepth(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return SoilMap[pos].r;
}
float GetWaterDepth(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
    return SoilWaterMap[pos].b;
}
float GetLandHeight(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return SoilMap[pos].a;
}

struct RootData
{
	float2 uv;
	float radius;
	float depth;
	int id;
	float absorbedWater;
};
StructuredBuffer<RootData> RootBuffer;
int NumRoots;


float GetSoakedWaterDepth(int2 xy)
{
	float currentWaterDepth = GetWaterDepth(xy);
	float newWaterDepth = currentWaterDepth * 0.4;
	int2 offsets[4] = { int2(1, 0), int2(-1, 0), int2(0, 1), int2(0, -1) };
	
	for (int i = 0; i < 4; i++) {
		int2 pos = xy + offsets[i];
		if (GetSoilDepth(pos) > currentWaterDepth * 0.1) {
			newWaterDepth += GetWaterDepth(pos) * 0.15;
		}
		else {
			newWaterDepth += GetWaterDepth(xy) * 0.15;
		}
	}

	return newWaterDepth;
}
float AbsorpWater(int2 xy, float amount)
{
	uint2 pos = clamp(xy, 0, 511);
	float availableWater = min(WaterMap[pos].b, WaterAbsorpsionRate);
	float absorpedWater = min(amount, availableWater);
	
	WaterMap[pos] = float4(WaterMap[pos].r, WaterMap[pos].g, WaterMap[pos].b - absorpedWater, WaterMap[pos].a - absorpedWater);
	
	return absorpedWater;
}
float ExpelWater(int2 xy, float amount)
{
	uint2 pos = clamp(xy, 0, 511);
	WaterMap[pos] = float4(WaterMap[pos].r, WaterMap[pos].g, WaterMap[pos].b + amount, WaterMap[pos].a + amount);
	return amount;
}

[numthreads(8, 8, 1)]
void UpdateSoil(uint3 id : SV_DispatchThreadID)
{
	float soilDepth = GetSoilDepth(id.xy);
	float waterDepth = GetSoakedWaterDepth(id.xy);
	float landHeight = GetLandHeight(id.xy);

	float excessWater = max(waterDepth - soilDepth, 0);
	waterDepth -= ExpelWater(id.xy, excessWater);
	float requestedWater = clamp(soilDepth - waterDepth, 0, WaterAbsorpsionRate);
	waterDepth += AbsorpWater(id.xy, requestedWater);
    float waterDiff = waterDepth - GetWaterDepth(id.xy); 
    
    AllMemoryBarrierWithGroupSync();

	//ROOT Stuff

	float2 sumWaterDirection = float2(0,0);
	float sumRootDepth;
	float2 cellXy = float2(id.xy.x, id.xy.y);

	for (int i = 0; i < NumRoots; i++) {
		float2 rootXy = RootBuffer[i].uv * WidthInPixels;
		float dist = distance(cellXy, rootXy);
		float rootDepth = smoothstep(RootBuffer[i].radius, 0, dist) * RootBuffer[i].depth;
		sumRootDepth += rootDepth;
		sumWaterDirection += ((cellXy - rootXy) / dist) * rootDepth;
	}

	float2 waterVelocity = sumWaterDirection / NumRoots;
	float waterHeight = landHeight - soilDepth + waterDepth;

	SoilWaterMap[id.xy] = float4(waterVelocity.x, waterVelocity.y, waterDepth, waterHeight);
    SoilMap[id.xy] = float4(soilDepth, min(sumRootDepth, soilDepth), 0, landHeight);
}
