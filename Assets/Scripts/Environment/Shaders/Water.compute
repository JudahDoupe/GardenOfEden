#pragma kernel Update
#pragma kernel Rain

Texture2D<float4> TerrainHeightMap;
RWTexture2D<float4> WaterMap;
RWTexture2D<float4> Result;
RWTexture2D<float4> Test;

static float PixelSpacingInMeters = 400.0f/512.0f; //400 = width of the texture in meters | 512 = width of the texture in pixels
static float Gravity = 90.8f;
static float Eps = 0.001;

// Accesors

float GetTerrainHeight(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return TerrainHeightMap[pos].r;
}
float GetHeight(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return GetTerrainHeight(pos) + WaterMap[pos].b;
}
float GetDepth(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
    return WaterMap[pos].b;
}
float2 GetVelocity(int2 xy) 
{
	uint2 pos = clamp(xy, 0, 511);
    return WaterMap[pos].rg;
}
float GetVelocityFace(int2 xy, int2 offset)
{
	if (offset.x == 1) {
		return GetVelocity(xy).x;
	}else if (offset.y == 1) {
		return GetVelocity(xy).y;
	}else if (offset.x == -1) {
		return GetVelocity(xy + offset).x;
	}else if (offset.y == -1) {
		return GetVelocity(xy + offset).y;
	}else {
		return 0;
	}
}

// Velocity

int Reflection(int2 xy, int2 offset) 
{
	int isReflective = (GetDepth(xy) < Eps && GetTerrainHeight(xy) > GetHeight(xy + offset)) ||
					   (GetDepth(xy + offset) < Eps && GetTerrainHeight(xy + offset) > GetHeight(xy)) ||
					   (xy + offset).x < 0 || (xy + offset).x >= 512 ||
					   (xy + offset).y < 0 || (xy + offset).y >= 512;
	return isReflective * 2 - 1;
}
float2 GetNewVelocity(int2 xy, float deltaSeconds)
{
	float2 externalForce = 0;
	int shouldPerserveVelocity = GetDepth(xy) > Eps;  //We have some water

    float2 neighborHeights = float2(GetHeight(xy + int2(1, 0)),
									GetHeight(xy + int2(0, 1)));
	int2 reflection = int2(Reflection(xy, int2(1, 0)),
						   Reflection(xy, int2(0, 1)));
	float2 heightDiffs = neighborHeights - GetHeight(xy);
	float relativeGravity = -Gravity / PixelSpacingInMeters;
	float2 changeInVelocity = (relativeGravity * heightDiffs + externalForce) * reflection * deltaSeconds;
	float2 newVelocity = (GetVelocity(xy) + changeInVelocity) * shouldPerserveVelocity;

	float maxVelocity = 0.5f * PixelSpacingInMeters / deltaSeconds;
	return clamp(newVelocity, -maxVelocity, maxVelocity);
}

// Height

float UpwindDepth(int2 xy, int2 offset)
{
	if (GetVelocityFace(xy, offset) <= 0)
		return GetDepth(xy + offset);
    else
		return GetDepth(xy);
}
float StabilizedUpwind(int2 xy, int2 offset, float deltaSeconds)
{
	float averageMaxDepth = 2.0f * PixelSpacingInMeters / Gravity * deltaSeconds;
	float adjacentDepth = max(0, (UpwindDepth(xy, int2(1,  0)) +
								  UpwindDepth(xy, int2(0,  1)) +
								  UpwindDepth(xy, int2(-1, 0)) +
								  UpwindDepth(xy, int2(0, -1))) / 4 - averageMaxDepth);
	return UpwindDepth(xy, offset) - adjacentDepth;
}
float Runoff(int2 xy, int2 offset, float deltaSeconds)
{
	return StabilizedUpwind(xy, offset, deltaSeconds) * GetVelocityFace(xy, offset);
}
float GetChangeInDepth(int2 xy, float deltaSeconds)
{
	float xRunoff = (Runoff(xy, int2(1, 0), deltaSeconds) - Runoff(xy, int2(-1, 0), deltaSeconds))
					/ PixelSpacingInMeters;
    float yRunoff = (Runoff(xy, int2(0, 1), deltaSeconds) - Runoff(xy, int2(0, -1), deltaSeconds))
					/ PixelSpacingInMeters;

    return -(xRunoff + yRunoff);
}
float GetNewDepth(int2 xy, float deltaSeconds)
{
    int isOnTerrain = GetTerrainHeight(xy) > 0;
	float newDepth = GetDepth(xy) + GetChangeInDepth(xy, deltaSeconds) * deltaSeconds;
	return clamp(newDepth * isOnTerrain, 0, 1);
}

// Kernels

[numthreads(8,8,1)]
void Update (uint3 id : SV_DispatchThreadID)
{ 
    float deltaSeconds = 1.0f/ 30.0f;

    float depth = GetNewDepth(id.xy, deltaSeconds);
    float2 velocity = GetNewVelocity(id.xy, deltaSeconds);

    Result[id.xy] = float4(velocity, depth, 1);
}

[numthreads(8, 8, 1)]
void Rain (uint3 id : SV_DispatchThreadID)
{
	float4 s = WaterMap[id.xy];
	s.b += 10.0f/512.0f;
	WaterMap[id.xy] = s;
}