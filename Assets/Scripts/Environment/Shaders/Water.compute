#pragma kernel Update
#pragma kernel Rain

Texture2D<float4> TerrainHeightMap;
RWTexture2D<float4> WaterMap;
RWTexture2D<float4> WaterVelocityMap;
RWTexture2D<float4> Result;
RWTexture2D<float4> Test;

static float PixelSpacingInMeters = 400.0f/512.0f; //400 = width of the texture in meters | 512 = width of the texture in pixels
static float Gravity = 9.8f;
static float Eps = 0.001;

float GetTerrainHeight(uint2 xy)
{
	return TerrainHeightMap[xy % 512].r;
}
float GetHeight(uint2 xy)
{
    return GetTerrainHeight(xy) + WaterMap[xy % 512].b;
}
float GetDepth(uint2 xy)
{
    return WaterMap[xy % 512].b;
}

int IsReflective(uint2 xy, int2 offset) 
{
	int isReflective = (GetDepth(xy) < Eps && GetTerrainHeight(xy) > GetHeight(xy + offset)) ||
					   (GetDepth(xy + offset) < Eps && GetTerrainHeight(xy + offset) > GetHeight(xy));
	return isReflective * 2 - 1;
}
void UpdateVelocity(uint2 xy, float deltaSeconds)
{
    float4 externalForce = 0;
    int shouldPerserveVelocity = GetDepth(xy) > Eps &&  //We have some water
								 xy.x % 512 != 0 &&	    //We are not on the edge of the map
								 xy.y % 512 != 0;

    float4 heightDiff = float4(GetHeight(xy + int2(1, 0)) - GetHeight(xy),
							   GetHeight(xy + int2(0, 1)) - GetHeight(xy),
							   GetHeight(xy + int2(-1, 0)) - GetHeight(xy),
							   GetHeight(xy + int2(0, -1)) - GetHeight(xy));
	int4 reflection = int4(IsReflective(xy, int2(1, 0)),
						   IsReflective(xy, int2(0, 1)),
						   IsReflective(xy, int2(-1, 0)),
						   IsReflective(xy, int2(0, -1)));
	float relativeGravity = -Gravity / PixelSpacingInMeters;
	float4 changeInVelocity = (relativeGravity * heightDiff + externalForce) * reflection * deltaSeconds;
	float4 newVelocity = WaterVelocityMap[xy] + changeInVelocity;

    WaterVelocityMap[xy] = clamp(newVelocity * shouldPerserveVelocity, 0, 1);
}

float Runoff(uint2 xy, int2 offset, float velocity)
{
    if (velocity <= 0)
        return GetDepth(xy + offset) * velocity;
    else
        return GetDepth(xy) * velocity;
}

float GetChangeInDepth(uint2 xy, float deltaSeconds)
{
    float xRunoff = (Runoff(xy, int2(1, 0), WaterVelocityMap[xy].r) 
				   - Runoff(xy, int2(-1, 0), WaterVelocityMap[xy].b)) / PixelSpacingInMeters;
    float yRunoff = (Runoff(xy, int2(0, 1), WaterVelocityMap[xy].g) 
				   - Runoff(xy, int2(0, -1), WaterVelocityMap[xy].a)) / PixelSpacingInMeters;
    return -(xRunoff + yRunoff) * deltaSeconds;
}

[numthreads(8,8,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    float deltaSeconds = 1.0f/ 30.0f;
    int isOnTerrain = TerrainHeightMap[id.xy].r > 0;

    float depth = clamp(GetDepth(id.xy) + GetChangeInDepth(id.xy, deltaSeconds), 0, 1) * isOnTerrain;

    UpdateVelocity(id.xy, deltaSeconds);
	 
    Result[id.xy] = float4(0, TerrainHeightMap[id.xy].r + depth, depth, 1);
}

[numthreads(8, 8, 1)]
void Rain (uint3 id : SV_DispatchThreadID)
{
	float4 s = WaterMap[id.xy];
	s.b += 1.0f/512.0f;
	WaterMap[id.xy] = s;
}