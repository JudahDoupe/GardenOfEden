#pragma kernel Update
#pragma kernel Rain

Texture2D<float4> TerrainHeightMap;
RWTexture2D<float4> WaterMap;
RWTexture2D<float4> Result;
RWTexture2D<float4> Test;

static float GridSpacing = 400.0f / 512.0f; //spacing in meters per pixel.  400 = width of the texture in meters | 512 = width of the texture in pixels
static float SimulationSpeed = 1.0f / 10.0f; //speed in seconds per time step. 1 = seconds | 4 = steps
static float Gravity = 9.8 * 9.8f;
static float Eps = 0.0001;

// Accesors

float GetTerrainHeight(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return TerrainHeightMap[pos].r;
}
float GetHeight(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
	return WaterMap[pos].a;
}
float GetDepth(int2 xy)
{
	uint2 pos = clamp(xy, 0, 511);
    return WaterMap[pos].b;
}
float2 GetVelocity(int2 xy) 
{
	uint2 pos = clamp(xy, 0, 511);
    return WaterMap[pos].rg;
}
float GetVelocityFace(int2 xy, int2 offset)
{
	if (offset.x == 1) {
		return GetVelocity(xy).x;
	}else if (offset.y == 1) {
		return GetVelocity(xy).y;
	}else if (offset.x == -1) {
		return GetVelocity(xy + offset).x;
	}else if (offset.y == -1) {
		return GetVelocity(xy + offset).y;
	}else {
		return 0;
	}
}

// Velocity

int ShouldPerserveVelocity(int2 xy, int2 offset)
{
	int isReflective = (GetDepth(xy) <= Eps && GetTerrainHeight(xy) > GetHeight(xy + offset)) ||
					   (GetDepth(xy + offset) <= Eps && GetTerrainHeight(xy + offset) > GetHeight(xy));
	int isEdge = (xy + offset).x < 0 || (xy + offset).x >= 512 ||
			     (xy + offset).y < 0 || (xy + offset).y >= 512;
	return !isReflective && !isEdge;
}
float2 GetNewVelocity(int2 xy)
{
	float2 externalForce = 0;

    float2 neighborHeights = float2(GetHeight(xy + int2(1, 0)), GetHeight(xy + int2(0, 1)));
	float2 heightDiffs = neighborHeights - GetHeight(xy);

	float relativeGravity = -Gravity / GridSpacing;
	float2 changeInVelocity = (relativeGravity * heightDiffs + externalForce) * SimulationSpeed;
	
	int2 shouldPerserveVelocity = int2(ShouldPerserveVelocity(xy, int2(1, 0)), ShouldPerserveVelocity(xy, int2(0, 1)));
	float2 newVelocity = (GetVelocity(xy) + changeInVelocity) * shouldPerserveVelocity;

	float maxVelocity = 0.5f * (GridSpacing / SimulationSpeed);
	return clamp(newVelocity, -maxVelocity, maxVelocity);
}

// Height

float UpwindDepth(int2 xy, int2 offset)
{
	int dir = dot(offset, int2(1,1));
	if (GetVelocityFace(xy, offset) * dir <= 0)
		return GetDepth(xy + offset);
    else
		return GetDepth(xy);
}
float StabilizedUpwind(int2 xy, int2 offset)
{
	float averageMaxDepth = 2.0f * GridSpacing / Gravity * SimulationSpeed;
	float adjacentDepth = max(0, (UpwindDepth(xy, int2(1,  0)) +
								  UpwindDepth(xy, int2(0,  1)) +
								  UpwindDepth(xy, int2(-1, 0)) +
								  UpwindDepth(xy, int2(0, -1))) / 4 - averageMaxDepth);
	return UpwindDepth(xy, offset) - adjacentDepth;
}
float Runoff(int2 xy, int2 offset)
{
	return StabilizedUpwind(xy, offset) * GetVelocityFace(xy, offset);
}
float GetChangeInDepth(int2 xy)
{
	float xRunoff = (Runoff(xy, int2(1, 0)) - Runoff(xy, int2(-1, 0))) / GridSpacing;
    float yRunoff = (Runoff(xy, int2(0, 1)) - Runoff(xy, int2(0, -1))) / GridSpacing;

    return -(xRunoff + yRunoff);
}
float GetNewDepth(int2 xy)
{
    int isOnTerrain = GetTerrainHeight(xy) > 0;
	float newDepth = GetDepth(xy) + GetChangeInDepth(xy) * SimulationSpeed;
	return clamp(newDepth * isOnTerrain, 0, 1);
}

// Kernels

[numthreads(8,8,1)]
void Update (uint3 id : SV_DispatchThreadID)
{ 
    float depth = GetNewDepth(id.xy);
    float2 velocity = GetNewVelocity(id.xy);

    Result[id.xy] = float4(velocity, depth, GetTerrainHeight(id.xy) + depth);
}

[numthreads(8, 8, 1)]
void Rain (uint3 id : SV_DispatchThreadID)
{
	float4 s = WaterMap[id.xy];
	s.b += 1.0f/150.0f;
	WaterMap[id.xy] = s;
}