#pragma kernel Update
#include "CoordinateTransforms.hlsl"

Texture2DArray<float4> LandMap;
Texture2DArray<float4> WaterSourceMap;
RWTexture2DArray<float4> WaterMap;

static float MaxHeight = 1000.0f;

static float GridSpacing = TextureWidthInMeters / TextureWidthInPixels;
static float SimulationSpeed = 1.0f / 50.0f; //speed in time steps per second. 1 = seconds | 50 = steps.  this is the speed of FixedUpdate
static float Gravity = 9.8f;

static float AmplitudeDampening = 0.6f;
static float VelocityDampening = 2.0f;

static float Eps = 0.00001f;

float GetTerrainHeight(int3 xyw)
{
    return LandMap[xyw].r;
}
float GetWaterSouceDepth(int3 xyw)
{
    return WaterSourceMap[xyw].r;
}
float GetHeight(int3 xyw)
{
    return WaterMap[xyw].a;
}
float GetDepth(int3 xyw)
{
    return WaterMap[xyw].b;
}
float2 GetVelocity(int3 xyw)
{
    return WaterMap[xyw].rg;
}
float GetVelocityFace(int3 xyw, int3 offset)
{
	if (offset.x == 1) {
        return GetVelocity(xyw).x;
    }else if (offset.y == 1) {
        return GetVelocity(xyw).y;
    }else if (offset.x == -1) {
        return GetVelocity(xyw + offset).x;
    }else if (offset.y == -1) {
        return GetVelocity(xyw + offset).y;
    }else {
		return 0;
	}
}

// Velocity

int ShouldPerserveVelocity(int3 xyw, int3 offset)
{
    int isReflective = (GetDepth(xyw) <= Eps && GetTerrainHeight(xyw) > GetHeight(xyw + offset)) ||
					   (GetDepth(xyw + offset) <= Eps && GetTerrainHeight(xyw + offset) > GetHeight(xyw));
	return !isReflective;
}
float2 GetNewVelocity(int3 xyw)
{
	float2 externalForce = 0;

    float2 neighborHeights = float2(GetHeight(xyw + int3(1, 0, 0)), GetHeight(xyw + int3(0, 1, 0)));
    float2 heightDiffs = neighborHeights - GetHeight(xyw);

	float relativeGravity = -Gravity / GridSpacing;
	float2 changeInVelocity = (relativeGravity * heightDiffs + externalForce) * SimulationSpeed;
	
    int2 shouldPerserveVelocity = int2(ShouldPerserveVelocity(xyw, int3(1, 0, 0)), ShouldPerserveVelocity(xyw, int3(0, 1, 0)));
    float2 newVelocity = (GetVelocity(xyw) + changeInVelocity) * shouldPerserveVelocity;

	float maxVelocity = (GridSpacing / SimulationSpeed) / VelocityDampening;
	return clamp(newVelocity, -maxVelocity, maxVelocity);
}

// Height

float UpwindDepth(int3 xyw, int3 offset)
{
    int dir = dot(xyw, int3(1, 1, 0));
    if (GetVelocityFace(xyw, offset) * dir <= 0)
        return GetDepth(xyw + offset);
    else
        return GetDepth(xyw);
}
float StabilizedUpwind(int3 xyw, int3 offset)
{
	float averageMaxDepth = (GridSpacing / (Gravity * SimulationSpeed)) / AmplitudeDampening;
    float averageUpwind = (UpwindDepth(xyw, int3(1, 0, 0)) +
						   UpwindDepth(xyw, int3(0, 1, 0)) +
						   UpwindDepth(xyw, int3(-1, 0, 0)) +
						   UpwindDepth(xyw, int3(0, -1, 0))) / 4;
	float adjacentDepth = max(0, (averageUpwind - averageMaxDepth));
    return UpwindDepth(xyw, offset) - adjacentDepth;
}
float Runoff(int3 xyw, int3 offset)
{
    float runoff = StabilizedUpwind(xyw, offset) * GetVelocityFace(xyw, offset);
	return runoff;
}
float GetChangeInDepth(int3 xyw)
{
    float xRunoff = (Runoff(xyw, int3(1, 0, 0)) - Runoff(xyw, int3(-1, 0, 0))) / GridSpacing;
    float yRunoff = (Runoff(xyw, int3(0, 1, 0)) - Runoff(xyw, int3(0, -1, 0))) / GridSpacing;

    return -(xRunoff + yRunoff) * SimulationSpeed;
}
float GetNewDepth(int3 xyw)
{
    float newDepth = GetDepth(xyw) + GetChangeInDepth(xyw);
    float clampedDepth = clamp(newDepth, GetWaterSouceDepth(xyw), MaxHeight);
	return clampedDepth;
}

// High Frequency Suppression

float EdgeSuppression(int3 xyz, int3 offset) {
	float maxEdge = 0.5f * GridSpacing;
	float suppressionRation = 0.25f;

    float myHeight = GetHeight(xyz);
    float edgeHeight = GetHeight(xyz + offset);
    float oppositeEdgeHeight = GetHeight(xyz + (offset * -1));

    float myDepth = GetDepth(xyz);
    float edgeDepth = GetDepth(xyz + offset);

	if (myHeight - oppositeEdgeHeight > maxEdge && myHeight > edgeHeight) {
		float avgDepth = (myDepth + edgeDepth) / 2.0f;
		return suppressionRation * (max(0,avgDepth) - myDepth);
	}
	else {
		return 0.0f;
	}
}
float HighFrequencySuppression(int3 xyz)
{
    return EdgeSuppression(xyz, int3(-1, 0, 0)) + EdgeSuppression(xyz, int3(1, 0, 0)) +
		EdgeSuppression(xyz, int3(0, -1, 0)) + EdgeSuppression(xyz, int3(0, 1, 0));
}

// Kernels

[numthreads(8,8,1)]
void Update (uint3 id : SV_DispatchThreadID)
{ 
	[unroll]
    for (int i = 0; i < 6; ++i)
    {
        int3 xyw = int3(id.xy, i);  

        float2 velocity = GetNewVelocity(xyw);
        float depth = GetNewDepth(xyw);
        float waterHeight = GetTerrainHeight(xyw) + depth;
        
        AllMemoryBarrierWithGroupSync();
        WaterMap[xyw] = float4(velocity, depth, waterHeight);
    
		//This does not conserve mass :(
        AllMemoryBarrierWithGroupSync();
        float hfs = HighFrequencySuppression(xyw);
        WaterMap[xyw] = float4(velocity, depth + hfs, waterHeight + hfs);
        
        AllMemoryBarrierWithGroupSync();
        if (isBoundryPixel(id.xy))
        {
            WaterMap[xyw] = WaterMap[overlapping_xyw(xyw)];
        }
    }
}
