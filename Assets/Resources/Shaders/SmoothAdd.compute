#pragma kernel SmoothAdd

RWTexture2DArray<float4> Map;
float4 Channels;
float Strength = 10;
float Radius = 10;
float3 TextureCenter;
float3 AdditionCenter;

static float TextureWidthInMeters = 401.568627451f;
static float TextureWidthInPixels = 512.0f; 

 #include "CoordinateTransforms.hlsl"

[numthreads(8, 8, 1)]
void SmoothAdd(uint3 id : SV_DispatchThreadID)
{
    [unroll]
    for (int i = 0; i < 6; ++i)
    {
        float3 uvw = float3(float(id.x) / (TextureWidthInPixels - 1), float(id.y) / (TextureWidthInPixels - 1), i);
        float3 xyz = abs(uvw_to_xyz(uvw));
 
         // This just puts a unique colored dot in the middle of the texture for each side
         // (Not important)
         {
            float dist = length(xyz);
            float3 centerColor = float3( // Find the color of the dot for this side
                 i / 2 == 0 || (i & 1 && i / 2 == 1),
                 i / 2 == 1 || (i & 1 && i / 2 == 2),
                 i / 2 == 2 || (i & 1 && i / 2 == 0));
            if (dist < 1.03)
                xyz = float3(0, 0, 0); // Outline
            if (dist < 1.02)
                xyz = centerColor; // Dot
        }
 

        float pixelRadius = (Radius / TextureWidthInMeters);
        float2 pixelUV = (id.xy / TextureWidthInPixels) + (TextureCenter.xz / TextureWidthInMeters);
        float2 additionUV = AdditionCenter.xz / TextureWidthInMeters;
        float d = distance(pixelUV, additionUV);
        float addend = smoothstep(pixelRadius, 0, d) * Strength;
    
        Map[int3(id.xy, i)] += Channels * addend;
    }
}
