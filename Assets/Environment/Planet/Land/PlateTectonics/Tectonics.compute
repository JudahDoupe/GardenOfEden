#pragma kernel UpdateHeightMap
#pragma kernel UpdatePlateThicknessMaps
#pragma kernel UpdateContinentalIdMap
#pragma kernel GeneratePlate

#include "../../../../Resources/Shaders/CoordinateTransforms.hlsl"
#include "../../../../Resources/Shaders/Quaternion.hlsl"
#include "../../../../Resources/Shaders/Noise.hlsl"

Texture2DArray<float> ContinentalIdMap_Safe;
RWTexture2DArray<float> ContinentalIdMap;
RWTexture2DArray<float> LandHeightMap;
RWTexture2DArray<float> PlateThicknessMaps;

Texture2DArray<float> PlateThicknessMaps_Read;
SamplerState samplerPlateThicknessMaps_Read
{
    Filter = MIN_MAG_MIP_LINEAR;
    BorderColor = 0;
    AddressU = Border;
    AddressV = Border;
};

struct Plate
{
    int Id;
    float4 Rotation;
};
RWStructuredBuffer<Plate> Plates;
uint NumPlates;
float OceanFloorHeight;
float SubductionRate;

[numthreads(8,8,1)]
void UpdateHeightMap (uint3 id : SV_DispatchThreadID)
{
    [unroll]
    for (uint w = 0; w < 6; w++)
    {
        uint3 xyw = uint3(id.xy, w);
        float height = 0;

        for (uint p = 0; p < NumPlates; p++)
        {
            Plate plate = Plates[p]; 
            float3 xyz = xyw_to_xyz(xyw, OceanFloorHeight);
            xyz = rotate_vector(xyz, q_inverse(plate.Rotation));
            float3 sampleUvw = xyz_to_uvw(xyz);
            float3 sampleUvp = float3(sampleUvw.xy, p);
            height += PlateThicknessMaps_Read.SampleLevel(samplerPlateThicknessMaps_Read, sampleUvp, 0).x * (sampleUvw.z == 4);
        }

        LandHeightMap[xyw] = OceanFloorHeight + height;
    }
}

[numthreads(8, 8, 1)]
void UpdateContinentalIdMap(uint3 id : SV_DispatchThreadID)
{
    [unroll]
    for (uint w = 0; w < 6; w++)
    {
        uint3 xyw = uint3(id.xy, w);
        float maxThickness = 0;
        uint plateId = 0;

        for (uint p = 0; p < NumPlates; p++)
        {
            Plate plate = Plates[p];
            float3 xyz = xyw_to_xyz(xyw, OceanFloorHeight);
            xyz = rotate_vector(xyz, q_inverse(plate.Rotation));
            float3 sampleUvw = xyz_to_uvw(xyz);
            float3 sampleUvp = float3(sampleUvw.xy, p);
            float thickness = PlateThicknessMaps_Read.SampleLevel(samplerPlateThicknessMaps_Read, sampleUvp, 0).x;
            if (thickness > maxThickness)
            {
                maxThickness = thickness;
                plateId = p;
            }
        }

        ContinentalIdMap[xyw] = plateId;
    }
}

[numthreads(8, 8, 1)]
void UpdatePlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    [unroll]
    for (uint w = 0; w < 6; w++)
    {
        uint3 xyw = uint3(id.xy, w);
        int topPlate = ContinentalIdMap[xyw];

        for (uint p0 = 0; p0 < NumPlates; p0++)
        {
            Plate myPlate = Plates[p0];
            int sign = ((myPlate.Id  == topPlate) * 2) - 1;
            float otherThickness = 0;
            
            float3 myXyz = xyw_to_xyz(xyw, OceanFloorHeight);
            myXyz = rotate_vector(myXyz, q_inverse(myPlate.Rotation));
            uint3 myXyw = xyz_to_xyw(myXyz);
            uint3 myXyp = uint3(myXyw.xy, p0);

            for (uint p1 = 0; p1 < NumPlates; p1++)
            {
                Plate otherPlate = Plates[p1];
                float3 otherXyz = xyw_to_xyz(xyw, OceanFloorHeight);
                otherXyz = rotate_vector(otherXyz, q_inverse(otherPlate.Rotation));
                float3 otherUvw = xyz_to_uvw(otherXyz);
                float3 otherUvp = float3(otherUvw.xy, p1);

                otherThickness += PlateThicknessMaps_Read.SampleLevel(samplerPlateThicknessMaps_Read, otherUvp, 0).x * (otherUvw.z == 4) * (p0 != p1);
            }

            PlateThicknessMaps[myXyp] = PlateThicknessMaps[myXyp] + sign * otherThickness * SubductionRate;
        }
    }
}

[numthreads(8, 8, 1)]
void GeneratePlate(uint3 id : SV_DispatchThreadID)
{
    for (uint p = 0; p < NumPlates; p++)
    {
        uint3 xyw = uint3(id.xy, p);
        float3 uvw = xyw_to_uvw(uint3(id.xy, 0));
        
        PlateThicknessMaps[xyw] = (1 - smoothstep(0.2f, 0.4f, distance(uvw.xy, float2(0.5, 0.5)))) * 100;
    }
}
