#pragma kernel ResetPlateThicknessMaps
#pragma kernel ResetContinentalIdMap
#pragma kernel UpdateContinentalIdMap
#pragma kernel UpdatePlateThicknessMaps
#pragma kernel SmoothPlates
#pragma kernel UpdateHeightMap
#pragma kernel StartAligningPlateThicknessMaps
#pragma kernel FinishAligningPlateThicknessMaps

#include "../../../../Resources/Shaders/CoordinateTransforms.hlsl"
#include "../../../../Resources/Shaders/Quaternion.hlsl"
#include "../../../../Resources/Shaders/Noise.hlsl"

RWTexture2DArray<float> ContinentalIdMap; 
RWTexture2DArray<float> PlateThicknessMaps;
RWTexture2DArray<float> TmpPlateThicknessMaps;
RWTexture2DArray<float> LandHeightMap;

struct Plate
{
    int Id;
    float4 Rotation;
}; 
RWStructuredBuffer<Plate> Plates;
uint NumPlates;
float FaultLineNoise; 
float SubductionRate;
float InflationRate;
float OceanicCrustThickness;
float MantleHeight;
float Gravity;
float PlateCohesion;
int RenderPlate;

uint3 xyz_to_xyp(float3 xyz, float4 rotation, int p) {
	uint3 xyw = xyz_to_xyw(rotate_vector(xyz, q_inverse(rotation)));
    return uint3(xyw.xy, xyw.z + (p * 6));
}
float3 xyp_to_xyz(uint3 xyp, float4 rotation) {

    uint3 xyw = uint3(xyp.xy, xyp.z % 6);
    return rotate_vector(xyw_to_xyz(xyw, MantleHeight), rotation);
}

[numthreads(8, 8, 6)]
void UpdateContinentalIdMap(uint3 id : SV_DispatchThreadID)
{
	uint plateId = ContinentalIdMap[id];
    float3 xyz = xyw_to_xyz(id, MantleHeight);
    float currentThickness = PlateThicknessMaps[xyz_to_xyp(xyz, Plates[plateId].Rotation, plateId)];
	int neighbors[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    
	for (int x = -1; x <= 1; x++)
	{
		for (int y = -1; y <= 1; y++)
		{
			int n = (x + 1) * 3 + (y + 1);
			int3 xyw = int3(id.x + x, id.y + y, id.z);
            neighbors[n] = ContinentalIdMap[xyz_to_xyw(xyw_to_xyz(xyw, MantleHeight))];
        }
	}
    
    for (uint p = 0; p < NumPlates; p++)
	{
		Plate plate = Plates[p];
		uint3 xyp = xyz_to_xyp(xyz, plate.Rotation, p);
		float thickness = PlateThicknessMaps[xyp];
        if (thickness > currentThickness * PlateCohesion)
		{
			for (int i = 0; i < 9; i++)
			{
				if (neighbors[i] == plate.Id)
				{
                    currentThickness = thickness;
					plateId = plate.Id;
				}
			}
		}
	}

    ContinentalIdMap[id] = plateId;
}

[numthreads(8, 8, 6)]
void UpdatePlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    for (uint p = 0; p < NumPlates; p++)
    {
        Plate myPlate = Plates[p];
        
		uint3 xyp = uint3(id.xy, id.z + p * 6);
        float3 xyz = xyp_to_xyz(xyp, myPlate.Rotation);
		uint3 xyw = xyz_to_xyw(xyz);
        
        float totalThickness = 0;
        for (uint p2 = 0; p2 < NumPlates; p2++)
        {
            Plate otherPlate = Plates[p2];
            uint3 otherXyp = xyz_to_xyp(xyz, otherPlate.Rotation, p2);
            totalThickness += PlateThicknessMaps[otherXyp];
        }
		
		bool isTopPlate = ContinentalIdMap[xyw] == myPlate.Id;
		float myThickness = PlateThicknessMaps[xyp];
		if (isTopPlate)
        {
			float targetThickness = max(OceanicCrustThickness, totalThickness);
            myThickness = lerp(myThickness, targetThickness, InflationRate);
        }
        else
        {
			float preasure = (myThickness - (totalThickness - myThickness)) / (totalThickness + 0.00000001f);
			float subduction = myThickness * max(-preasure, 0) * SubductionRate;
			myThickness = max(myThickness - subduction, 0);
        }
		
        PlateThicknessMaps[xyp] = myThickness;
    }
}

[numthreads(8, 8, 6)]
void SmoothPlates(uint3 id : SV_DispatchThreadID)
{
    for (uint p = 0; p < NumPlates; p++)
    {
        Plate myPlate = Plates[p];
        
        uint3 xyp = uint3(id.xy, id.z + p * 6);
        
        float sumThickness = 0;
        float sumWeights = 0;
        for (int x = -1; x <= 1; x++)
        {
            for (int y = -1; y <= 1; y++)
            {
                int3 xyw = int3(id.x + x, id.y + y, id.z);
                if (is_boundry_pixel(xyw.xy))
                {
                    xyw = get_source_xyw(xyw);
                }
                int3 xyp2 = int3(xyw.xy, xyw.z + p * 6);
                float dist = length(float2(x,y));
                float weight = pow(2.71828, -((dist * dist) / (Gravity * Gravity)));
                sumThickness += PlateThicknessMaps[xyp2] * weight;
                sumWeights += weight;

            }
        }
		
        PlateThicknessMaps[xyp] = sumThickness / sumWeights;
    }
}

[numthreads(8, 8, 6)]
void UpdateHeightMap(uint3 id : SV_DispatchThreadID)
{
    float height = MantleHeight;
    int plateId = ContinentalIdMap[id] * (RenderPlate == 0) + RenderPlate * (RenderPlate != 0);

    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        float3 xyp = xyz_to_xyp(xyw_to_xyz(id, MantleHeight), plate.Rotation, p);
        height += PlateThicknessMaps[xyp] * (plate.Id == plateId);
    }

    LandHeightMap[id] = height;
}

[numthreads(8, 8, 6)]
void StartAligningPlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    float3 xyz = xyw_to_xyz(id, MantleHeight);
	
    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        uint3 xyp = xyz_to_xyp(xyz, plate.Rotation, p);
        uint3 xypTmp = uint3(id.xy, id.z + p * 6);
        TmpPlateThicknessMaps[xypTmp] = PlateThicknessMaps[xyp];
    }
}

[numthreads(8, 8, 6)]
void FinishAligningPlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    for (uint p = 0; p < NumPlates; p++)
    {
        uint3 xyp = uint3(id.xy, id.z + p * 6);
        PlateThicknessMaps[xyp] = TmpPlateThicknessMaps[xyp];
    }
}

[numthreads(8, 8, 6)]
void ResetPlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    for (uint p = 0; p < NumPlates; p++)
	{
		Plate myPlate = Plates[p];
		uint3 xyp = uint3(id.xy, id.z + p * 6);
		float3 xyz = rotate_vector(xyw_to_xyz(id, MantleHeight), myPlate.Rotation);
	    xyz = xyz + noise3d(xyz, FaultLineNoise);
		float minDist = 1000000;
		int closestPlateId = 0;

		for (uint p2 = 0; p2 < NumPlates; p2++)
		{
			Plate plate = Plates[p2];
			float3 centerXyz = rotate_vector(float3(0, 0, MantleHeight), plate.Rotation);

			float dist = distance(xyz, centerXyz);
			if (dist < minDist)
			{
				minDist = dist;
				closestPlateId = plate.Id;
			}
		}

		PlateThicknessMaps[xyp] = myPlate.Id * (closestPlateId == myPlate.Id);
	}
}

[numthreads(8, 8, 6)]
void ResetContinentalIdMap(uint3 id : SV_DispatchThreadID)
{
	float maxThickness = 0;
	uint plateId = ContinentalIdMap[id];
	float3 xyz = xyw_to_xyz(id, MantleHeight);
    
	for (uint p = 0; p < NumPlates; p++)
	{
		Plate plate = Plates[p];
		uint3 xyp = xyz_to_xyp(xyz, plate.Rotation, p);
		float thickness = PlateThicknessMaps[xyp];
		if (thickness > maxThickness)
		{
			maxThickness = thickness;
			plateId = plate.Id;
		}
	}

	ContinentalIdMap[id] = plateId;
}
