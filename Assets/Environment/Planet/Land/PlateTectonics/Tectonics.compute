#pragma kernel UpdateHeightMap
#pragma kernel UpdateContinentalIdMap
#pragma kernel GeneratePlate

#include "../../../../Resources/Shaders/CoordinateTransforms.hlsl"
#include "../../../../Resources/Shaders/Quaternion.hlsl"
#include "../../../../Resources/Shaders/Noise.hlsl"

RWTexture2DArray<float> ContinentalIdMap;
RWTexture2DArray<float> LandHeightMap;
RWTexture2DArray<float> PlateThicknessMaps;

struct Plate
{
    int Id;
    float4 Rotation;
};
RWStructuredBuffer<Plate> Plates;
uint NumPlates;
float OceanFloorHeight;



[numthreads(8,8,1)]
void UpdateHeightMap (uint3 id : SV_DispatchThreadID)
{
    [unroll]
    for (uint w = 0; w < 6; w++)
    {
        uint3 xyw = uint3(id.xy, w);
        float height = 0;

        for (uint p = 0; p < NumPlates; p++)
        {
            Plate plate = Plates[p];
            float3 xyz = xyw_to_xyz(xyw, OceanFloorHeight);
            xyz = rotate_vector(xyz, q_inverse(plate.Rotation));
            uint3 sampleXyw = xyz_to_xyw(xyz);
            uint3 sampleXyp = uint3(sampleXyw.xy, p);
            height += PlateThicknessMaps[sampleXyp] * (sampleXyw.z == 4);
        }

        LandHeightMap[xyw] = OceanFloorHeight + height;
    }
}

[numthreads(8, 8, 1)]
void UpdateContinentalIdMap(uint3 id : SV_DispatchThreadID)
{
    [unroll]
    for (uint w = 0; w < 6; w++)
    {
        uint3 xyw = uint3(id.xy, w);
        float maxThickness = 0;
        uint plateId = 0;

        for (uint p = 0; p < NumPlates; p++)
        {
            uint3 sampleXyw = uint3(id.xy, p);
            float thickness = PlateThicknessMaps[sampleXyw];
            if (thickness > maxThickness)
            {
                maxThickness = thickness;
                plateId = p;
            }
        }

        ContinentalIdMap[xyw] = plateId;
    }
}

[numthreads(8, 8, 1)]
void GeneratePlate(uint3 id : SV_DispatchThreadID)
{
    for (uint p = 0; p < NumPlates; p++)
    {
        uint3 xyw = uint3(id.xy, p);
        float3 uvw = xyw_to_uvw(uint3(id.xy, 0));
        
        PlateThicknessMaps[xyw] = (1 - smoothstep(0.2f, 0.4f, distance(uvw.xy, float2(0.5, 0.5)))) * 100;
    }
}
