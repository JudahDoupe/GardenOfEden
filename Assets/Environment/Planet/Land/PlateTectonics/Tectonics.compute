#pragma kernel UpdateHeightMap
#pragma kernel UpdatePlateThicknessMaps
#pragma kernel UpdateContinentalIdMap
#pragma kernel Reset

#include "../../../../Resources/Shaders/CoordinateTransforms.hlsl"
#include "../../../../Resources/Shaders/Quaternion.hlsl"
#include "../../../../Resources/Shaders/Noise.hlsl"

RWTexture2DArray<float> ContinentalIdMap;

RWTexture2DArray<float> LandHeightMap;
Texture2DArray<float> LandHeightMap_Read;
SamplerState samplerLandHeightMap_Read
{
    Filter = MIN_MAG_MIP_LINEAR;
    BorderColor = 0;
    AddressU = Border;
    AddressV = Border;
};

RWTexture2DArray<float> PlateThicknessMaps;
Texture2DArray<float> PlateThicknessMaps_Read;
SamplerState samplerPlateThicknessMaps_Read
{
    Filter = MIN_MAG_MIP_LINEAR;
    BorderColor = 0;
    AddressU = Border;
    AddressV = Border;
};

struct Plate
{
    int Id;
    float4 Rotation;
};
RWStructuredBuffer<Plate> Plates;
uint NumPlates;
float OceanFloorHeight;
float SubductionRate;
float InitialThickness;

[numthreads(8, 8, 6)]
void UpdateContinentalIdMap(uint3 id : SV_DispatchThreadID)
{
    uint3 xyw = id;
    float maxThickness = 0;
    uint plateId = 0;
    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        float3 sampleXyz = rotate_vector(xyw_to_xyz(xyw, OceanFloorHeight), q_inverse(plate.Rotation));
        float3 sampleUvw = xyz_to_uvw(sampleXyz);
        float3 sampleUvp = float3(sampleUvw.xy, sampleUvw.z + (p * 6));
        float thickness = PlateThicknessMaps_Read.SampleLevel(samplerPlateThicknessMaps_Read, sampleUvp, 0).x;
        if (thickness > maxThickness)
        {
            maxThickness = thickness;
            plateId = p;
        }
    }

    ContinentalIdMap[xyw] = plateId;
}

[numthreads(8, 8, 6)]
void UpdatePlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    for (uint p = 0; p < NumPlates; p++)
    {
        Plate myPlate = Plates[p];
        uint3 xyp = uint3(id.xy, id.z + p * 6);
        float3 xyz = rotate_vector(xyw_to_xyz(id, OceanFloorHeight), myPlate.Rotation);
        float3 uvw = xyz_to_uvw(xyz);

        float myThickness = PlateThicknessMaps[xyp];
        float otherThickness = LandHeightMap_Read.SampleLevel(samplerLandHeightMap_Read, uvw, 0).x - OceanFloorHeight - myThickness;
        int topPlate = ContinentalIdMap[uvw_to_xyw(uvw)];

        myThickness -= SubductionRate * (myPlate.Id != topPlate) * myThickness;
        myThickness += SubductionRate * (myPlate.Id == topPlate) * otherThickness;

        PlateThicknessMaps[xyp] = myThickness;
    }
}

[numthreads(8, 8, 6)]
void UpdateHeightMap(uint3 id : SV_DispatchThreadID) 
{
    uint3 xyw = id;
    float height = 0;

    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        float3 xyz = xyw_to_xyz(xyw, OceanFloorHeight);
        xyz = rotate_vector(xyz, q_inverse(plate.Rotation));
        float3 sampleUvw = xyz_to_uvw(xyz);
        float3 sampleUvp = float3(sampleUvw.xy, sampleUvw.z + (p * 6));
        height += PlateThicknessMaps_Read.SampleLevel(samplerPlateThicknessMaps_Read, sampleUvp, 0).x;
    }

    LandHeightMap[xyw] = OceanFloorHeight + height;
}

[numthreads(8, 8, 6)]
void Reset(uint3 id : SV_DispatchThreadID)
{
    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        uint3 xyp = uint3(id.xy, id.z + (p * 6));
        float3 xyz = rotate_vector(xyw_to_xyz(id, OceanFloorHeight), plate.Rotation);
        int minId = 0;
        float minDist = OceanFloorHeight * 10;

        for (uint p2 = 0; p2 < NumPlates; p2++)
        {
            Plate plate2 = Plates[p2];
            float3 xyz2 = rotate_vector(float3(0, 0, OceanFloorHeight), plate2.Rotation);
            float dist = distance(xyz, xyz2);

            if (dist < minDist)
            {
                minDist = dist;
                minId = plate2.Id;
            }
        }

        PlateThicknessMaps[xyp] = InitialThickness * (minId == plate.Id);
    }
}
