#pragma kernel StartAligningPlateThicknessMaps
#pragma kernel FinishAligningPlateThicknessMaps

#include "../../../../Resources/Shaders/CoordinateTransforms.hlsl"
#include "../../../../Resources/Shaders/Quaternion.hlsl"
#include "../../../../Resources/Shaders/Noise.hlsl"

RWTexture2DArray<float> PlateThicknessMaps;
RWTexture2DArray<float> TmpPlateThicknessMaps;

struct Plate
{
    float Id;
    int Idx;
    float4 Rotation;
}; 
RWStructuredBuffer<Plate> Plates;
uint NumPlates;
float MantleHeight;

uint3 xyz_to_xyp(float3 xyz, float4 rotation, int p) {
	uint3 xyw = xyz_to_xyw(rotate_vector(xyz, q_inverse(rotation)));
    return uint3(xyw.xy, xyw.z + (p * 6));
}

[numthreads(8, 8, 6)]
void StartAligningPlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    float3 xyz = xyw_to_xyz(id, MantleHeight);
	
    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        uint3 xyp = xyz_to_xyp(xyz, plate.Rotation, p);
        uint3 xypTmp = uint3(id.xy, id.z + p * 6);
        TmpPlateThicknessMaps[xypTmp] = PlateThicknessMaps[xyp];
    }
}

[numthreads(8, 8, 6)]
void FinishAligningPlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    for (uint p = 0; p < NumPlates; p++)
    {
        uint3 xyp = uint3(id.xy, id.z + p * 6);
        PlateThicknessMaps[xyp] = TmpPlateThicknessMaps[xyp];
    }
}