#pragma kernel UpdateContinentalIdMap
#pragma kernel UpdatePlateThicknessMaps
#pragma kernel SmoothPlates
#pragma kernel UpdateHeightMap

#include "PlateTectonicsInclude.hlsl"

RWTexture2DArray<float> ContinentalIdMap; 
RWTexture2DArray<float> PlateThicknessMaps;
RWTexture2DArray<float> TmpPlateThicknessMaps;
RWTexture2DArray<float> LandHeightMap;

float SimulationTimeStep;
float MinSubductionPressure;
float StillPlateInflationRate;
float MovingPlateInflationRate;
float OceanicCrustThickness;
float MaxThickness;
float MaxSlope;

float PlateCohesionRatio;
int PlateCohesionKernelSize;

[numthreads(8, 8, 6)]
void UpdateContinentalIdMap(uint3 id : SV_DispatchThreadID)
{
    float3 xyz = xyw_to_xyz(id, MantleHeight);
	float maxThickness = 0;
	float thickestPlateId = 0;
	for (uint p = 0; p < NumPlates; p++)
	{
		Plate plate = Plates[p];
		uint3 xyp = xyz_to_xyp(xyz, p);
		float thickness = PlateThicknessMaps[xyp];
		if (thickness > maxThickness)
		{
			maxThickness = thickness;
			thickestPlateId = plate.Id;
		}
	}

	int neighborCount = 0;
	for (int x = -PlateCohesionKernelSize; x <= PlateCohesionKernelSize; x++)
	{
		for (int y = -PlateCohesionKernelSize; y <= PlateCohesionKernelSize; y++)
		{
			uint3 xyw2 = xyz_to_xyw(xyw_to_xyz(id + uint3(x,y,0), MantleHeight));
			neighborCount += ContinentalIdMap[xyw2] == thickestPlateId;
        }
	}

	float neighborRatio = neighborCount / (PlateCohesionKernelSize * PlateCohesionKernelSize);
	if (neighborRatio >= PlateCohesionRatio)
	{
		ContinentalIdMap[id] = thickestPlateId;
	}
}

[numthreads(8, 8, 6)]
void UpdatePlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    float3 xyz = xyw_to_xyz(id, MantleHeight);
    float totalThickness = 0;
    float totalTravelDistance = 0;
    for (uint p1 = 0; p1 < NumPlates; p1++)
    {
        uint3 xyp = xyz_to_xyp(xyz, p1);
        float plateThickness = PlateThicknessMaps[xyp];
        totalThickness += plateThickness;
        totalTravelDistance += Plates[p1].TravelDistance * (plateThickness > 0);
    }
    
    for (uint p2 = 0; p2 < NumPlates; p2++)
    {
        Plate plate = Plates[p2];
        uint3 xyp = xyz_to_xyp(xyz, p2);
        bool isTopPlate = ContinentalIdMap[id] == plate.Id;
		float myThickness = PlateThicknessMaps[xyp];
        float otherThickness = totalThickness - myThickness;
		
		if (isTopPlate)
        {
            //Infalation
            float inflationRate = lerp(StillPlateInflationRate * SimulationTimeStep, MovingPlateInflationRate * SimulationTimeStep, saturate(totalTravelDistance));
			inflationRate = lerp(inflationRate, 0, saturate(myThickness / MaxThickness));

			float targetThickness = clamp(totalThickness, OceanicCrustThickness, MaxThickness);
            myThickness = lerp(myThickness, targetThickness, inflationRate);
        }
        else
        {
            //Subduction
			float preasure = clamp((otherThickness - myThickness) / (totalThickness + 0.00000001), MinSubductionPressure, 1);
            float subduction = otherThickness * preasure * SimulationTimeStep;
			myThickness = max(myThickness - subduction, 0);
        }
		
        PlateThicknessMaps[xyp] = myThickness;
    }
}

[numthreads(8, 8, 6)]
void SmoothPlates(uint3 id : SV_DispatchThreadID)
{
    Plate myPlate = Plates[GetPlateIdx(ContinentalIdMap[id])]; 

	float left = LandHeightMap[get_source_xyw(int3(id.xy + int2(-1, 0), id.z))] - MantleHeight;
	float right = LandHeightMap[get_source_xyw(int3(id.xy + int2(1, 0), id.z))] - MantleHeight;
	float up = LandHeightMap[get_source_xyw(int3(id.xy + int2(0, 1), id.z))] - MantleHeight;
	float down = LandHeightMap[get_source_xyw(int3(id.xy + int2(0, -1), id.z))] - MantleHeight;
	float center = LandHeightMap[id] - MantleHeight;
    
	float slope = (abs(center - left) +
	               abs(center - right) +
	               abs(center - up)  +
	               abs(center - down)) / 4.0;

	float t = saturate(slope - MaxSlope);
	float outerWeight = lerp(0, 0.2, t);
	float centerWeight = lerp(1, 0.2, t);
	
	int3 xyp = xyw_to_xyp(id, myPlate.Idx);
	PlateThicknessMaps[xyp] = (left * outerWeight) +
							  (right * outerWeight) +
							  (up * outerWeight) +
							  (down * outerWeight) +
							  (center * centerWeight);
}

[numthreads(8, 8, 6)]
void UpdateHeightMap(uint3 id : SV_DispatchThreadID)
{
    float height = MantleHeight;

    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        bool isTopPlate = ContinentalIdMap[id] == plate.Id;
        float3 xyp = xyw_to_xyp(id, p);
        height += PlateThicknessMaps[xyp] * isTopPlate;
    }

    LandHeightMap[id] = height;
}