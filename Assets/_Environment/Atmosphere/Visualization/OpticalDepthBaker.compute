#pragma kernel BakeOpticalDepth

RWTexture2D<float> Result;
int textureSize;
int numOutScatteringSteps;
float atmosphereRadius;
float seaLevel;
float densityFalloff;

float2 raySphere(float3 sphereCenter, float sphereRadius, float3 rayOrigin, float3 rayDir)
{
	float3 offset = rayOrigin - sphereCenter;
	float a = 1; // Set to dot(rayDir, rayDir) if rayDir might not be normalized
	float b = 2 * dot(offset, rayDir);
	float c = dot (offset, offset) - sphereRadius * sphereRadius;
	float d = b * b - 4 * a * c; // Discriminant from quadratic formula

	// Number of intersections: 0 when d < 0; 1 when d = 0; 2 when d > 0
	if (d > 0) {
		float s = sqrt(d);
		float dstToSphereNear = max(0, (-b - s) / (2 * a));
		float dstToSphereFar = (-b + s) / (2 * a);

		// Ignore intersections that occur behind the ray
		if (dstToSphereFar >= 0) {
			return float2(dstToSphereNear, dstToSphereFar - dstToSphereNear);
		}
	}

	return float2(3.402823466e+38, 0);
}

float densityAtPoint(float2 densitySamplePoint) 
{
	float heightAboveSurface = length(densitySamplePoint) - seaLevel;
	float height01 = heightAboveSurface / (atmosphereRadius - seaLevel);
	float localDensity = exp(-height01 * densityFalloff) * (1 - height01);
	return localDensity;
}

float opticalDepth(float2 rayOrigin, float2 rayDir, float rayLength) 
{
	float2 densitySamplePoint = rayOrigin;
	float stepSize = rayLength / numOutScatteringSteps;
	float opticalDepth = 0;

	for (int i = 0; i < numOutScatteringSteps; i ++) {
		float localDensity = densityAtPoint(densitySamplePoint);
		opticalDepth += localDensity * stepSize;
		densitySamplePoint += rayDir * stepSize;
	}
	return opticalDepth;
}


float calculateOutScattering(float2 inPoint, float2 outPoint) {
	float skinWidth = seaLevel / 1000.0;

	float lightTravelDst = length(outPoint - inPoint);
	float2 outScatterPoint = inPoint;
	float2 rayDir = (outPoint - inPoint) / lightTravelDst;
	float stepSize = (lightTravelDst - skinWidth) / (numOutScatteringSteps);

	float outScatterAmount = 0;

	for (int i = 0; i < numOutScatteringSteps; i ++) {
		outScatterPoint += rayDir * stepSize;
		float height = length(outScatterPoint) - seaLevel;

		float height01 = saturate(height / (atmosphereRadius - seaLevel));
		outScatterAmount += exp(-height01 * densityFalloff) * stepSize;

	}

	return outScatterAmount;
}

[numthreads(8, 8, 1)]
void BakeOpticalDepth (uint2 id : SV_DispatchThreadID)
{
	float2 uv = id / (float)textureSize;
	float height01 = uv.y;
	float angle = uv.x * 3.141529;
	float2 dir = float2(sin(angle), cos(angle));
	float y = -2 * uv.x + 1;
	float x = sin(acos(y));
	dir = float2(x,y);

	float2 inPoint = float2(0, lerp(seaLevel, atmosphereRadius, height01));
	float dstThroughAtmosphere = raySphere(0, atmosphereRadius, float3(inPoint,0), float3(dir,0)).y;
	float2 outPoint = inPoint + dir * raySphere(0, atmosphereRadius, float3(inPoint,0), float3(dir,0)).y;
	float outScattering = opticalDepth(inPoint + dir * 0.0001, dir, dstThroughAtmosphere-0.0002); 

	Result[id.xy] = outScattering;
}