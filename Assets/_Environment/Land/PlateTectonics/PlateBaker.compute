#pragma kernel InitializeLabeling
#pragma kernel RunLabelingIteration
#pragma kernel RelabelContinents

#include "PlateTectonicsInclude.hlsl"

RWTexture2DArray<float> PlateThicknessMaps;
RWTexture2DArray<float> ContinentalIdMap;
RWTexture2DArray<float> TmpContinentalIdMap;
RWTexture2DArray<float> LandHeightMap;

struct LabelData
{
    int Changed;
}; 
RWStructuredBuffer<LabelData> Label;

struct RelabelData
{
    float From;
    float To;
};
RWStructuredBuffer<RelabelData> Relabels;
int NumRelabels;


[numthreads(8, 8, 6)]
void InitializeLabeling(uint3 id : SV_DispatchThreadID)
{
    TmpContinentalIdMap[id] = id.x + (id.y * TextureWidthInPixels) + (id.z * TextureWidthInPixels * TextureWidthInPixels);
}

int IsBetterLabel(uint3 center, uint3 neighbor){
    return TmpContinentalIdMap[neighbor] > TmpContinentalIdMap[center] && ContinentalIdMap[neighbor] == ContinentalIdMap[center];
}

[numthreads(8, 8, 6)]
void RunLabelingIteration(uint3 id : SV_DispatchThreadID)
{
    uint3 center = get_source_xyw(id);
    uint3 up = get_source_xyw(center + uint3(0,1,0));
    uint3 upRight = get_source_xyw(center + uint3(1,1,0));
    uint3 right = get_source_xyw(center + uint3(1,0,0));
    uint3 rightDown = get_source_xyw(center + uint3(1,-1,0));
    uint3 down = get_source_xyw(center + uint3(0,-1,0));
    uint3 downLeft = get_source_xyw(center + uint3(-1,-1,0));
    uint3 left = get_source_xyw(center + uint3(-1,0,0));
    uint3 leftUp = get_source_xyw(center + uint3(-1,1,0));
    
    float startingValue = TmpContinentalIdMap[id];

    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[up] * IsBetterLabel(id, up));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[upRight] * IsBetterLabel(id, upRight));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[right] * IsBetterLabel(id, right));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[rightDown] * IsBetterLabel(id, rightDown));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[down] * IsBetterLabel(id, down));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[downLeft] * IsBetterLabel(id, downLeft));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[left] * IsBetterLabel(id, left));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[leftUp] * IsBetterLabel(id, leftUp));

    if (TmpContinentalIdMap[id] != startingValue)
    {
        Label[0].Changed = 1;
    }
}

[numthreads(8, 8, 6)]
void RelabelContinents(uint3 id : SV_DispatchThreadID)
{
    for (int i = 0; i < NumRelabels; i++){
        if (round(Relabels[i].From) == round(TmpContinentalIdMap[id])){
            ContinentalIdMap[id] = Relabels[i].To;
        }
    }

    for (uint p = 0; p < NumPlates; p++){
        Plate plate = GetPlate(ContinentalIdMap[id]);
        float thickness = (LandHeightMap[id] - MantleHeight) * (ContinentalIdMap[id] == plate.Id);
        PlateThicknessMaps[xyw_to_xyp(id, plate.Idx)] = thickness;
    }
}