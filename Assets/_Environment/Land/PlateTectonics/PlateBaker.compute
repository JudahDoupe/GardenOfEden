#pragma kernel AlignPlateThicknessMaps
#pragma kernel InitializeLabeling
#pragma kernel RunLabelingIteration
#pragma kernel RelabelContinents

#include "PlateTectonicsInclude.hlsl"

RWTexture2DArray<float> PlateThicknessMaps;
RWTexture2DArray<float> TmpPlateThicknessMaps;
RWTexture2DArray<float> ContinentalIdMap;
RWTexture2DArray<float> TmpContinentalIdMap;

struct LabelData
{
    int Changed;
}; 
RWStructuredBuffer<LabelData> Label;

struct RelabelData
{
    float From;
    float To;
    float ToIdx;
};
RWStructuredBuffer<RelabelData> Relabels;
int NumRelabels;


[numthreads(8, 8, 6)]
void AlignPlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    float3 xyz = xyw_to_xyz(id, MantleHeight);
	
    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        uint3 xyp = xyz_to_xyp(xyz, p);
        uint3 xypTmp = uint3(id.xy, id.z + p * 6);
        TmpPlateThicknessMaps[xypTmp] = PlateThicknessMaps[xyp];
    }
}

[numthreads(8, 8, 6)]
void InitializeLabeling(uint3 id : SV_DispatchThreadID)
{
    TmpContinentalIdMap[id] = id.x + (id.y * TextureWidthInPixels) + (id.z * TextureWidthInPixels * TextureWidthInPixels);
}

int IsBetterLabel(uint3 center, uint3 neighbor){
    return TmpContinentalIdMap[neighbor] > TmpContinentalIdMap[center] && ContinentalIdMap[neighbor] == ContinentalIdMap[center];
}

[numthreads(8, 8, 6)]
void RunLabelingIteration(uint3 id : SV_DispatchThreadID)
{
    uint3 center = get_source_xyw(id);
    uint3 up = get_source_xyw(center + uint3(0,1,0));
    uint3 upRight = get_source_xyw(center + uint3(1,1,0));
    uint3 right = get_source_xyw(center + uint3(1,0,0));
    uint3 rightDown = get_source_xyw(center + uint3(1,-1,0));
    uint3 down = get_source_xyw(center + uint3(0,-1,0));
    uint3 downLeft = get_source_xyw(center + uint3(-1,-1,0));
    uint3 left = get_source_xyw(center + uint3(-1,0,0));
    uint3 leftUp = get_source_xyw(center + uint3(-1,1,0));
    
    float startingValue = TmpContinentalIdMap[id];

    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[up] * IsBetterLabel(id, up));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[upRight] * IsBetterLabel(id, upRight));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[right] * IsBetterLabel(id, right));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[rightDown] * IsBetterLabel(id, rightDown));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[down] * IsBetterLabel(id, down));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[downLeft] * IsBetterLabel(id, downLeft));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[left] * IsBetterLabel(id, left));
    TmpContinentalIdMap[id] = max(TmpContinentalIdMap[id], TmpContinentalIdMap[leftUp] * IsBetterLabel(id, leftUp));

    if (TmpContinentalIdMap[id] != startingValue)
    {
        Label[0].Changed = 1;
    }
}

[numthreads(8, 8, 6)]
void RelabelContinents(uint3 id : SV_DispatchThreadID)
{
    for (int i = 0; i < NumRelabels; i++){
        if (round(Relabels[i].From) == round(TmpContinentalIdMap[id])){
            TmpContinentalIdMap[id] = Relabels[i].To;
            TmpPlateThicknessMaps[xyw_to_xyp(id, Relabels[i].ToIdx)] = PlateThicknessMaps[xyw_to_xyp(id, GetPlateIdx(ContinentalIdMap[id]))];
        }
    }
}