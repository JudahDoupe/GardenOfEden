#pragma kernel VisualizeBreakLine
#pragma kernel BreakPlate

#include "../PlateTectonicsInclude.hlsl"

RWTexture2DArray<float> VisualizedContinentalIdMap; 
RWTexture2DArray<float> ContinentalIdMap; 
RWTexture2DArray<float> PlateThicknessMaps;

float FaultLineNoise;
float OldPlateId; 
float NewPlateId; 
float OldPlateIdx;
float NewPlateIdx;
float3 OldPlateCenter;
float3 NewPlateCenter;


[numthreads(8, 8, 6)]
void VisualizeBreakLine(uint3 id : SV_DispatchThreadID)
{
    float3 xyz = xyw_to_xyz(id, MantleHeight);
    xyz = xyz + noise3d(xyz, FaultLineNoise);
    xyz = xyz + noise3d(xyz, FaultLineNoise / 6.35);
    xyz = xyz + noise3d(xyz, FaultLineNoise / 11.7);
    
    float oldDist = distance(xyz, OldPlateCenter);
    float newDist = distance(xyz, NewPlateCenter);

    bool isNewPlate = oldDist >= newDist && VisualizedContinentalIdMap[id] != 0;
    
    VisualizedContinentalIdMap[id] = !isNewPlate * VisualizedContinentalIdMap[id]
                                   + isNewPlate * NewPlateId;
}

[numthreads(8, 8, 6)]
void BreakPlate(uint3 id : SV_DispatchThreadID)
{
    float3 xyz = xyw_to_xyz(id, MantleHeight);
    xyz = xyz + noise3d(xyz, FaultLineNoise);
    xyz = xyz + noise3d(xyz, FaultLineNoise / 6.35);
    xyz = xyz + noise3d(xyz, FaultLineNoise / 11.7);
    
    float oldDist = distance(xyz, OldPlateCenter);
    float newDist = distance(xyz, NewPlateCenter);
    
    if (oldDist >= newDist)
    {
        uint3 oldXyp = uint3(id.x, id.y, OldPlateIdx * 6 + id.z);
        uint3 newXyp = uint3(id.x, id.y, NewPlateIdx * 6 + id.z);
        
        PlateThicknessMaps[newXyp] = PlateThicknessMaps[oldXyp];
        PlateThicknessMaps[oldXyp] = 0;

        int isOldPlate = ContinentalIdMap[id] == OldPlateId;
        ContinentalIdMap[id] = !isOldPlate * ContinentalIdMap[id]
                             + isOldPlate * NewPlateId;
    }
}
