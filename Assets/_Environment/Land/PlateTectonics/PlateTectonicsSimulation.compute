#pragma kernel UpdateContinentalIdMap
#pragma kernel UpdatePlateThicknessMaps
#pragma kernel SmoothPlates
#pragma kernel UpdateHeightMap

#include "PlateTectonicsInclude.hlsl"

RWTexture2DArray<float> ContinentalIdMap; 
RWTexture2DArray<float> PlateThicknessMaps;
RWTexture2DArray<float> TmpPlateThicknessMaps;
RWTexture2DArray<float> LandHeightMap;

float StillPlateSubductionRate;
float MovingPlateSubductionRate;
float StillMinSubductionPressure;
float MovingMinSubductionPressure;
float StillPlateInflationRate;
float MovingPlateInflationRate;
float OceanicCrustThickness;
float MaxThickness;
float MaxSlope;
float PlateCohesion;

[numthreads(8, 8, 6)]
void UpdateContinentalIdMap(uint3 id : SV_DispatchThreadID)
{
	float plateId = ContinentalIdMap[id];
    uint pIdx = GetPlateIdx(plateId);
    float3 xyz = xyw_to_xyz(id, MantleHeight);
    float currentThickness = PlateThicknessMaps[xyz_to_xyp(xyz, pIdx)];
	float neighbors[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    
	for (int x = -1; x <= 1; x++)
	{
		for (int y = -1; y <= 1; y++)
		{
			int n = (x + 1) * 3 + (y + 1);
			int3 xyw = int3(id.x + x, id.y + y, id.z);
            neighbors[n] = ContinentalIdMap[xyz_to_xyw(xyw_to_xyz(xyw, MantleHeight))];
        }
	}
    
    for (uint p = 0; p < NumPlates; p++)
	{
		Plate plate = Plates[p];
		uint3 xyp = xyz_to_xyp(xyz, p);
		float thickness = PlateThicknessMaps[xyp];
        if (thickness > currentThickness * PlateCohesion)
		{
			for (int i = 0; i < 9; i++)
			{
				if (neighbors[i] == plate.Id)
				{
                    currentThickness = thickness;
					plateId = plate.Id;
				}
			}
		}
	}

    ContinentalIdMap[id] = plateId;
}

[numthreads(8, 8, 6)]
void UpdatePlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    float3 xyz = xyw_to_xyz(id, MantleHeight);
    float totalThickness = 0;
    float totalTravelDistance = 0;
    for (uint p1 = 0; p1 < NumPlates; p1++)
    {
        uint3 xyp = xyz_to_xyp(xyz, p1);
        float plateThickness = PlateThicknessMaps[xyp];
        totalThickness += plateThickness;
        totalTravelDistance += Plates[p1].TravelDistance * saturate(plateThickness / OceanicCrustThickness);
    }
    
    for (uint p2 = 0; p2 < NumPlates; p2++)
    {
        Plate plate = Plates[p2];
        uint3 xyp = xyz_to_xyp(xyz, p2);
        bool isTopPlate = ContinentalIdMap[id] == plate.Id;
		float myThickness = PlateThicknessMaps[xyp];
        float otherThickness = totalThickness - myThickness;
		
		if (isTopPlate)
        {
            //Infalation
            float inflationRate = lerp(StillPlateInflationRate, MovingPlateInflationRate, saturate(totalTravelDistance));
			float inflationDampening = saturate(myThickness / MaxThickness);
			inflationRate = lerp(inflationRate, 0, inflationDampening);

			float targetThickness = clamp(totalThickness, OceanicCrustThickness, MaxThickness);
            myThickness = lerp(myThickness, targetThickness, inflationRate);
        }
        else
        {
            //Subduction
            float subductionRate = lerp(StillPlateSubductionRate, MovingPlateSubductionRate, saturate(totalTravelDistance));
            float minSubductionPreasure = lerp(StillMinSubductionPressure, MovingMinSubductionPressure, saturate(totalTravelDistance));
			float preasure = clamp((otherThickness - myThickness) / (totalThickness + 0.00000001), minSubductionPreasure, 1);
            float heightLimitingFactor = pow(1 + (totalThickness / MantleHeight), 3);
            float subduction = myThickness * preasure * subductionRate * heightLimitingFactor;
			myThickness = max(myThickness - subduction, 0);
        }
		
        PlateThicknessMaps[xyp] = myThickness;
    }
}

[numthreads(8, 8, 6)]
void SmoothPlates(uint3 id : SV_DispatchThreadID)
{
    Plate myPlate = Plates[GetPlateIdx(ContinentalIdMap[id])]; 

	float left = LandHeightMap[get_source_xyw(int3(id.xy + int2(-1, 0), id.z))] - MantleHeight;
	float right = LandHeightMap[get_source_xyw(int3(id.xy + int2(1, 0), id.z))] - MantleHeight;
	float up = LandHeightMap[get_source_xyw(int3(id.xy + int2(0, 1), id.z))] - MantleHeight;
	float down = LandHeightMap[get_source_xyw(int3(id.xy + int2(0, -1), id.z))] - MantleHeight;
	float center = LandHeightMap[id] - MantleHeight;
    
	float slope = (abs(center - left) +
	               abs(center - right) +
	               abs(center - up)  +
	               abs(center - down)) / 4.0;

	float t = saturate(slope - MaxSlope);
	float outerWeight = lerp(0, 0.2, t);
	float centerWeight = lerp(1, 0.2, t);
	
	int3 xyp = xyw_to_xyp(id, myPlate.Idx);
	PlateThicknessMaps[xyp] = (left * outerWeight) +
							  (right * outerWeight) +
							  (up * outerWeight) +
							  (down * outerWeight) +
							  (center * centerWeight);
}

[numthreads(8, 8, 6)]
void UpdateHeightMap(uint3 id : SV_DispatchThreadID)
{
    float height = MantleHeight;
    float plateId = ContinentalIdMap[id];

    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        float3 xyp = xyw_to_xyp(id, p);
        height += PlateThicknessMaps[xyp] * (plate.Id == ContinentalIdMap[id]);
    }

    LandHeightMap[id] = height;
}