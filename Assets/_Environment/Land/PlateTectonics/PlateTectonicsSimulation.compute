#pragma kernel UpdateContinentalIdMap
#pragma kernel UpdatePlateThicknessMaps
#pragma kernel SmoothPlates
#pragma kernel UpdateHeightMap

#include "PlateTectonicsInclude.hlsl"

RWTexture2DArray<float> ContinentalIdMap; 
RWTexture2DArray<float> PlateThicknessMaps;
RWTexture2DArray<float> TmpPlateThicknessMaps;
RWTexture2DArray<float> LandHeightMap;

float StillPlateSubductionRate;
float MovingPlateSubductionRate;
float StillMinSubductionPreasure;
float MovingMinSubductionPreasure;
float StillPlateInflationRate;
float MovingPlateInflationRate;
float OceanicCrustThickness;
float Gravity;
float PlateCohesion;

[numthreads(8, 8, 6)]
void UpdateContinentalIdMap(uint3 id : SV_DispatchThreadID)
{
	float plateId = ContinentalIdMap[id];
    uint pIdx = GetPlateIdx(plateId);
    float3 xyz = xyw_to_xyz(id, MantleHeight);
    float currentThickness = PlateThicknessMaps[xyz_to_xyp(xyz, pIdx)];
	float neighbors[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    
	for (int x = -1; x <= 1; x++)
	{
		for (int y = -1; y <= 1; y++)
		{
			int n = (x + 1) * 3 + (y + 1);
			int3 xyw = int3(id.x + x, id.y + y, id.z);
            neighbors[n] = ContinentalIdMap[xyz_to_xyw(xyw_to_xyz(xyw, MantleHeight))];
        }
	}
    
    for (uint p = 0; p < NumPlates; p++)
	{
		Plate plate = Plates[p];
		uint3 xyp = xyz_to_xyp(xyz, p);
		float thickness = PlateThicknessMaps[xyp];
        if (thickness > currentThickness * PlateCohesion)
		{
			for (int i = 0; i < 9; i++)
			{
				if (neighbors[i] == plate.Id)
				{
                    currentThickness = thickness;
					plateId = plate.Id;
				}
			}
		}
	}

    ContinentalIdMap[id] = plateId;
}

[numthreads(8, 8, 6)]
void UpdatePlateThicknessMaps(uint3 id : SV_DispatchThreadID)
{
    float3 xyz = xyw_to_xyz(id, MantleHeight);
    float totalThickness = 0;
    float totalTravelDistance = 0;
    for (uint p1 = 0; p1 < NumPlates; p1++)
    {
        uint3 xyp = xyz_to_xyp(xyz, p1);
        float plateThickness = PlateThicknessMaps[xyp];
        totalThickness += plateThickness;
        totalTravelDistance += Plates[p1].TravelDistance * saturate(plateThickness / OceanicCrustThickness);
    }
    
    for (uint p2 = 0; p2 < NumPlates; p2++)
    {
        Plate plate = Plates[p2];
        uint3 xyp = xyz_to_xyp(xyz, p2);
        bool isTopPlate = ContinentalIdMap[id] == plate.Id;
		float myThickness = PlateThicknessMaps[xyp];
        float otherThickness = totalThickness - myThickness;
		
		if (isTopPlate)
        {
            //Infalation
            float inflationRate = lerp(StillPlateInflationRate, MovingPlateInflationRate, saturate(totalTravelDistance));
			float targetThickness = max(OceanicCrustThickness, totalThickness);
            myThickness = lerp(myThickness, targetThickness, inflationRate);
        }
        else
        {
            //Subduction
            float subductionRate = lerp(StillPlateSubductionRate, MovingPlateSubductionRate, saturate(totalTravelDistance));
            float minSubductionPreasure = lerp(StillMinSubductionPreasure, MovingMinSubductionPreasure, saturate(totalTravelDistance));
			float preasure = clamp((otherThickness - myThickness) / (totalThickness + 0.00000001), minSubductionPreasure, 1);
            float heightLimitingFactor = pow(1 + (totalThickness / MantleHeight), 3);
            float subduction = myThickness * preasure * subductionRate * heightLimitingFactor;
			myThickness = max(myThickness - subduction, 0);
        }
		
        PlateThicknessMaps[xyp] = myThickness;
    }
}

[numthreads(8, 8, 6)]
void SmoothPlates(uint3 id : SV_DispatchThreadID)
{
    Plate myPlate = Plates[GetPlateIdx(ContinentalIdMap[id])]; 
    
    float sumThickness = 0;
    float sumWeights = 0;

    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            int3 xyw = int3(id.xy + int2(x, y), id.z);
            if (is_boundry_pixel(xyw.xy))
            {
                xyw = get_source_xyw(xyw);
            }
            float dist = length(float2(x, y));
            float weight = pow(2.71828, -((dist * dist) / (Gravity * Gravity)));
            sumThickness += (LandHeightMap[xyw] - MantleHeight) * weight;
            sumWeights += weight;
        }
    }
    int3 xyp = xyw_to_xyp(id, myPlate.Idx);
    PlateThicknessMaps[xyp] = sumThickness / sumWeights;
}

[numthreads(8, 8, 6)]
void UpdateHeightMap(uint3 id : SV_DispatchThreadID)
{
    float height = MantleHeight;
    float plateId = ContinentalIdMap[id];

    for (uint p = 0; p < NumPlates; p++)
    {
        Plate plate = Plates[p];
        float3 xyp = xyw_to_xyp(id, p);
        height += PlateThicknessMaps[xyp] * (plate.Id == ContinentalIdMap[id]);
    }

    LandHeightMap[id] = height;
}